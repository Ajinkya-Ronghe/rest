convertToPDF(data: any[]): Blob {
  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 10; // Left and right margin
  const cellPadding = 3; // Padding inside cells
  const lineHeight = 6; // Height of a single line of text
  const headerHeight = 10; // Height for the header row

  // Extract column headers
  const headers = Object.keys(data[0]);

  // Calculate column widths based on content and headers
  const columnWidths = headers.map(header => {
    const maxContentWidth = Math.max(
      pdf.getTextWidth(header),
      ...data.map(row => pdf.getTextWidth(String(row[header] || '')))
    );
    return maxContentWidth + cellPadding * 2; // Add padding to calculated width
  });

  // Scale column widths to fit within the page width if needed
  const totalWidth = columnWidths.reduce((sum, width) => sum + width, 0);
  const scaleFactor = totalWidth > pageWidth - 2 * margin ? (pageWidth - 2 * margin) / totalWidth : 1;
  const adjustedWidths = columnWidths.map(width => width * scaleFactor);

  // Add a title
  pdf.text('Exported Data', margin, margin);

  // Start drawing the table
  let currentY = margin + 10; // Start position below the title
  let currentX = margin;

  // Draw header row
  headers.forEach((header, index) => {
    const columnWidth = adjustedWidths[index];
    pdf.rect(currentX, currentY, columnWidth, headerHeight); // Draw the header cell
    const wrappedHeader = pdf.splitTextToSize(header, columnWidth - cellPadding * 2); // Wrap text for header
    pdf.text(wrappedHeader, currentX + cellPadding, currentY + headerHeight / 2 + lineHeight / 2); // Centered text
    currentX += columnWidth;
  });

  // Move to the first row
  currentY += headerHeight;

  // Draw data rows
  data.forEach(row => {
    currentX = margin; // Reset X position for each row
    let maxCellHeight = headerHeight; // Reset row height

    headers.forEach((header, index) => {
      const columnWidth = adjustedWidths[index];
      const cellText = row[header] !== undefined ? String(row[header]) : '';
      const wrappedText = pdf.splitTextToSize(cellText, columnWidth - cellPadding * 2);
      const cellHeight = wrappedText.length * lineHeight + cellPadding; // Calculate height based on wrapped text

      maxCellHeight = Math.max(maxCellHeight, cellHeight); // Adjust row height based on tallest cell

      // Draw the cell
      pdf.rect(currentX, currentY, columnWidth, cellHeight); // Draw the cell rectangle
      pdf.text(wrappedText, currentX + cellPadding, currentY + cellPadding + 4); // Add wrapped text
      currentX += columnWidth; // Move to the next column
    });

    currentY += maxCellHeight; // Move to the next row
  });

  // Return the PDF content as a Blob
  return pdf.output('blob');
}
