convertToPDF(data: any[]): Blob {
  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 10;
  const cellPadding = 2;
  const cellHeight = 10;

  // Extract column headers (keys from the first object)
  const headers = Object.keys(data[0]);

  // Add title
  pdf.text('Exported Data', margin, margin);

  // Calculate column width (divide equally for simplicity)
  const columnWidth = (pageWidth - 2 * margin) / headers.length;

  // Draw header row
  let currentY = margin + 10; // Start below the title
  headers.forEach((header, index) => {
    const xPos = margin + index * columnWidth;
    pdf.rect(xPos, currentY, columnWidth, cellHeight); // Draw cell
    pdf.text(header, xPos + cellPadding, currentY + cellHeight / 2 + 2); // Add header text
  });

  // Draw rows
  currentY += cellHeight; // Move to the next row
  data.forEach((row) => {
    let maxCellHeight = cellHeight; // Track the tallest cell in the row
    headers.forEach((header, index) => {
      const xPos = margin + index * columnWidth;
      const cellText = row[header] !== undefined ? String(row[header]) : '';
      
      // Wrap text using splitTextToSize
      const wrappedText = pdf.splitTextToSize(cellText, columnWidth - 2 * cellPadding);
      const textHeight = wrappedText.length * 6; // Approximate height of text based on number of lines

      // Update the max cell height for this row
      maxCellHeight = Math.max(maxCellHeight, textHeight + cellPadding);

      // Draw cell
      pdf.rect(xPos, currentY, columnWidth, textHeight + cellPadding);
      pdf.text(wrappedText, xPos + cellPadding, currentY + cellPadding + 4); // Add wrapped text
    });

    // Move to the next row
    currentY += maxCellHeight;
  });

  // Return the PDF as a Blob
  return pdf.output('blob');
}
