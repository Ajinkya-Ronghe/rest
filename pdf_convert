Step 1: Add a Utility Function to Convert rgba to RGB
Create a helper function to convert rgba() or rgb() strings into an array [R, G, B].

typescript
Copy code
convertColorToRGB(color: string): number[] {
  // Check if the color is in rgba() or rgb() format
  const rgbaMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if (rgbaMatch) {
    return [parseInt(rgbaMatch[1]), parseInt(rgbaMatch[2]), parseInt(rgbaMatch[3])];
  }

  // Default to black if the color format is invalid
  return [0, 0, 0];
}
Step 2: Modify generatePDF to Use the Utility Function
Use the convertColorToRGB function to ensure the background and text colors are passed correctly to jsPDF.

typescript
Copy code
import { jsPDF } from 'jspdf';

generatePDF(): void {
  const { headers, rows } = this.extractTableData();

  if (headers.length === 0 || rows.length === 0) {
    console.error('No data found in the table');
    return;
  }

  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 10;
  const fontHeight = 10;
  let y = margin;

  // Add Title
  pdf.setFontSize(14);
  pdf.text('Exported Table', margin, y);
  y += fontHeight + 5;

  // Calculate Column Widths
  const columnWidth = (pageWidth - 2 * margin) / headers.length;

  // Render Headers
  headers.forEach((header, index) => {
    const x = margin + index * columnWidth;

    // Convert colors using the utility function
    const textColor = this.convertColorToRGB(header.styles.color || 'rgb(0, 0, 0)');
    const backgroundColor = this.convertColorToRGB(header.styles.backgroundColor || 'rgb(255, 255, 255)');

    // Apply header styles
    pdf.setFontSize(parseInt(header.styles.fontSize) || 10);
    pdf.setFont(header.styles.fontWeight === 'bold' ? 'helvetica' : 'normal', 'bold');
    pdf.setTextColor(...textColor); // Apply text color
    pdf.setFillColor(...backgroundColor); // Apply background color
    pdf.rect(x, y - fontHeight, columnWidth, fontHeight, 'F'); // Draw background
    pdf.text(header.text, x + 2, y - 2); // Add text
  });
  y += fontHeight;

  // Render Rows
  rows.forEach((row) => {
    row.forEach((cell, index) => {
      const x = margin + index * columnWidth;

      // Convert colors using the utility function
      const textColor = this.convertColorToRGB(cell.styles.color || 'rgb(0, 0, 0)');
      const backgroundColor = this.convertColorToRGB(cell.styles.backgroundColor || 'rgb(255, 255, 255)');

      // Apply cell styles
      pdf.setFontSize(parseInt(cell.styles.fontSize) || 10);
      pdf.setFont(cell.styles.fontWeight === 'bold' ? 'helvetica' : 'normal', 'normal');
      pdf.setTextColor(...textColor); // Apply text color
      pdf.setFillColor(...backgroundColor); // Apply background color
      pdf.rect(x, y - fontHeight, columnWidth, fontHeight, 'F'); // Draw background
      pdf.text(cell.text, x + 2, y - 2); // Add text
    });
    y += fontHeight;

    // Add a new page if necessary
    if (y + fontHeight > pdf.internal.pageSize.getHeight() - margin) {
      pdf.addPage();
      y = margin;
    }
  });

  // Save PDF
  pdf.save('table.pdf');
}Step 1: Add a Utility Function to Convert rgba to RGB
Create a helper function to convert rgba() or rgb() strings into an array [R, G, B].

typescript
Copy code
convertColorToRGB(color: string): number[] {
  // Check if the color is in rgba() or rgb() format
  const rgbaMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if (rgbaMatch) {
    return [parseInt(rgbaMatch[1]), parseInt(rgbaMatch[2]), parseInt(rgbaMatch[3])];
  }

  // Default to black if the color format is invalid
  return [0, 0, 0];
}
Step 2: Modify generatePDF to Use the Utility Function
Use the convertColorToRGB function to ensure the background and text colors are passed correctly to jsPDF.

typescript
Copy code
import { jsPDF } from 'jspdf';

generatePDF(): void {
  const { headers, rows } = this.extractTableData();

  if (headers.length === 0 || rows.length === 0) {
    console.error('No data found in the table');
    return;
  }

  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 10;
  const fontHeight = 10;
  let y = margin;

  // Add Title
  pdf.setFontSize(14);
  pdf.text('Exported Table', margin, y);
  y += fontHeight + 5;

  // Calculate Column Widths
  const columnWidth = (pageWidth - 2 * margin) / headers.length;

  // Render Headers
  headers.forEach((header, index) => {
    const x = margin + index * columnWidth;

    // Convert colors using the utility function
    const textColor = this.convertColorToRGB(header.styles.color || 'rgb(0, 0, 0)');
    const backgroundColor = this.convertColorToRGB(header.styles.backgroundColor || 'rgb(255, 255, 255)');

    // Apply header styles
    pdf.setFontSize(parseInt(header.styles.fontSize) || 10);
    pdf.setFont(header.styles.fontWeight === 'bold' ? 'helvetica' : 'normal', 'bold');
    pdf.setTextColor(...textColor); // Apply text color
    pdf.setFillColor(...backgroundColor); // Apply background color
    pdf.rect(x, y - fontHeight, columnWidth, fontHeight, 'F'); // Draw background
    pdf.text(header.text, x + 2, y - 2); // Add text
  });
  y += fontHeight;

  // Render Rows
  rows.forEach((row) => {
    row.forEach((cell, index) => {
      const x = margin + index * columnWidth;

      // Convert colors using the utility function
      const textColor = this.convertColorToRGB(cell.styles.color || 'rgb(0, 0, 0)');
      const backgroundColor = this.convertColorToRGB(cell.styles.backgroundColor || 'rgb(255, 255, 255)');

      // Apply cell styles
      pdf.setFontSize(parseInt(cell.styles.fontSize) || 10);
      pdf.setFont(cell.styles.fontWeight === 'bold' ? 'helvetica' : 'normal', 'normal');
      pdf.setTextColor(...textColor); // Apply text color
      pdf.setFillColor(...backgroundColor); // Apply background color
      pdf.rect(x, y - fontHeight, columnWidth, fontHeight, 'F'); // Draw background
      pdf.text(cell.text, x + 2, y - 2); // Add text
    });
    y += fontHeight;

    // Add a new page if necessary
    if (y + fontHeight > pdf.internal.pageSize.getHeight() - margin) {
      pdf.addPage();
      y = margin;
    }
  });

  // Save PDF
  pdf.save('table.pdf');
}
