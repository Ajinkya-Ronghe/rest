generatePDFFromJSON(jsonData: any[]): void {
  if (!jsonData || jsonData.length === 0) {
    console.error('No data provided for the PDF');
    return;
  }

  // Extract breadcrumb title from the HTML
  const breadcrumbElement = document.querySelector('.breadcrumb span:nth-child(2)');
  const title = breadcrumbElement?.textContent?.trim() || 'Exported Table'; // Default title if not found

  // Extract all unique keys as headers
  const headers = Array.from(
    new Set(jsonData.flatMap((row) => Object.keys(row)))
  );

  // Ensure rows map to all headers
  const rows = jsonData.map((row) =>
    headers.map((header) => (row[header] !== undefined ? row[header] : ''))
  );

  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 10;
  const fontHeight = 10;
  const columnWidth = (pageWidth - 2 * margin) / headers.length;
  let y = margin;

  // Add dynamic title to the PDF
  pdf.setFontSize(14);
  pdf.setFont('helvetica', 'bold');
  pdf.text(title, pageWidth / 2, y, { align: 'center' });
  y += fontHeight + 5;

  // Function to render headers
  const renderHeaders = () => {
    headers.forEach((header, index) => {
      const x = margin + index * columnWidth;

      // Header styles
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(0, 0, 0); // Black text
      pdf.setFillColor(230, 230, 230); // Light gray background
      pdf.rect(x, y, columnWidth, fontHeight, 'F'); // Draw background
      pdf.text(header, x + 2, y + fontHeight - 2); // Add header text
    });
    y += fontHeight;
  };

  // Render headers on the first page
  renderHeaders();

  // Render rows
  rows.forEach((row) => {
    let maxRowHeight = fontHeight; // Initialize maximum row height

    row.forEach((cell, index) => {
      const x = margin + index * columnWidth;

      // Cell styles
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(0, 0, 0); // Black text
      pdf.setFillColor(255, 255, 255); // White background

      // Split text to fit within the column
      const wrappedText = pdf.splitTextToSize(cell?.toString(), columnWidth - 4);
      const cellHeight = wrappedText.length * fontHeight * 0.75; // Calculate height based on wrapped text

      // Draw background for the cell
      pdf.rect(x, y, columnWidth, cellHeight, 'F');
      pdf.text(wrappedText, x + 2, y + fontHeight - 2); // Add wrapped text

      // Update max row height
      maxRowHeight = Math.max(maxRowHeight, cellHeight);
    });

    y += maxRowHeight; // Move to the next row

    // Check if a new page is needed
    if (y + fontHeight > pageHeight - margin) {
      pdf.addPage(); // Add a new page
      y = margin; // Reset y position
      renderHeaders(); // Render headers on the new page
    }
  });

  // Save the PDF with the title as the file name
  pdf.save(`${title}.pdf`);
}
