generatePDF(jsonData: any[]): void {
  if (!jsonData || jsonData.length === 0) {
    console.error('No data provided for the PDF');
    return;
  }

  const tableTitleElement = Array.from(document.querySelectorAll('.tableTitle')).find(
    (el) => el.textContent?.trim() === this.data.title
  );

  if (!tableTitleElement) {
    console.error('Table with the matching title not found');
    return;
  }

  const table = tableTitleElement.closest('.table-wrapper');
  if (!table) {
    console.error('Table wrapper not found for the matching title');
    return;
  }

  // Extract JSON key to Header mappings
  const columns = Array.from(table.querySelectorAll('mat-header-cell')).map((cell) => ({
    jsonKey: cell.getAttribute('matColumnDef') || '', // Default fallback for safety
    header: cell.textContent?.trim() || '', // Ensure it's never undefined
  }));

  if (columns.length === 0) {
    console.error('No columns found in the table');
    return;
  }

  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 10;
  const fontHeight = 4;
  const columnWidth = (pageWidth - 2 * margin) / columns.length;
  let y = margin;

  // Pre-calculate header height
  let headerMaxHeight = 0;
  columns.forEach((col) => {
    const wrappedHeaderText = pdf.splitTextToSize(col.header, columnWidth - 4);
    const headerHeight = wrappedHeaderText.length * fontHeight * 1.3;
    headerMaxHeight = Math.max(headerMaxHeight, headerHeight);
  });

  // Render Headers
  const renderHeaders = () => {
    columns.forEach((col, index) => {
      const x = margin + index * columnWidth;
      pdf.setFillColor(200, 200, 200); // Gray background
      pdf.rect(x, y, columnWidth, headerMaxHeight, 'F');

      const wrappedHeaderText = pdf.splitTextToSize(col.header, columnWidth - 4);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(0, 0, 0);
      pdf.text(wrappedHeaderText, x + 2, y + fontHeight, { baseline: 'top' });
    });
    y += headerMaxHeight;
  };

  renderHeaders();

  // Render Rows
  jsonData.forEach((row) => {
    let rowMaxHeight = 0;

    columns.forEach((col, index) => {
      const x = margin + index * columnWidth;
      const cellValue = row[col.jsonKey] !== undefined ? row[col.jsonKey].toString() : ''; // Safely access JSON
      const wrappedText = pdf.splitTextToSize(cellValue, columnWidth - 4);
      const cellHeight = wrappedText.length * fontHeight * 1.3;

      rowMaxHeight = Math.max(rowMaxHeight, cellHeight);

      pdf.setFillColor(255, 255, 255);
      pdf.rect(x, y, columnWidth, cellHeight, 'F');
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(0, 0, 0);
      pdf.text(wrappedText, x + 2, y + fontHeight, { baseline: 'top' });
    });

    y += rowMaxHeight;

    // Add new page if required
    if (y + fontHeight > pageHeight - margin) {
      pdf.addPage();
      y = margin;
      renderHeaders();
    }
  });

  pdf.save(`${this.data.title}.pdf`);
}
