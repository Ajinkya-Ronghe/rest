Updated Function to Extract Data and Styles
typescript
Copy code
extractTableData(): { headers: { text: string; styles: any }[]; rows: { text: string; styles: any }[][] } {
  const table = document.querySelector('mat-table') as HTMLElement;

  if (!table) {
    console.error('No <mat-table> found on the page');
    return { headers: [], rows: [] };
  }

  const headers: { text: string; styles: any }[] = [];
  const rows: { text: string; styles: any }[][] = [];

  // Extract headers with styles
  const headerCells = table.querySelectorAll('mat-header-cell');
  headerCells.forEach((cell) => {
    const headerCell = cell as HTMLElement; // Cast to HTMLElement
    const styles = window.getComputedStyle(headerCell); // Extract computed styles
    headers.push({
      text: headerCell.textContent?.trim() || '',
      styles: {
        fontSize: styles.fontSize,
        fontWeight: styles.fontWeight,
        textAlign: styles.textAlign,
        backgroundColor: styles.backgroundColor,
        color: styles.color,
      },
    });
  });

  // Extract rows with styles
  const rowElements = table.querySelectorAll('mat-row');
  rowElements.forEach((row) => {
    const cells: { text: string; styles: any }[] = [];
    row.querySelectorAll('mat-cell').forEach((cell) => {
      const tableCell = cell as HTMLElement; // Cast to HTMLElement
      const styles = window.getComputedStyle(tableCell); // Extract computed styles
      cells.push({
        text: tableCell.textContent?.trim() || '',
        styles: {
          fontSize: styles.fontSize,
          fontWeight: styles.fontWeight,
          textAlign: styles.textAlign,
          backgroundColor: styles.backgroundColor,
          color: styles.color,
        },
      });
    });
    rows.push(cells);
  });

  return { headers, rows };
}
Updated generatePDF Function
This function now applies the extracted CSS styles (font size, text alignment, background color, etc.) while rendering the table into the PDF.

typescript
Copy code
import { jsPDF } from 'jspdf';

generatePDF(): void {
  const { headers, rows } = this.extractTableData();

  if (headers.length === 0 || rows.length === 0) {
    console.error('No data found in the table');
    return;
  }

  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 10;
  const fontHeight = 10;
  let y = margin;

  // Add Title
  pdf.setFontSize(14);
  pdf.text('Exported Table', margin, y);
  y += fontHeight + 5;

  // Calculate Column Widths
  const columnWidth = (pageWidth - 2 * margin) / headers.length;

  // Render Headers with Styles
  headers.forEach((header, index) => {
    const x = margin + index * columnWidth;

    // Apply header styles
    pdf.setFontSize(parseInt(header.styles.fontSize) || 10);
    pdf.setFont(header.styles.fontWeight === 'bold' ? 'helvetica' : 'normal', 'bold');
    pdf.setTextColor(header.styles.color || '#000000');
    pdf.setFillColor(header.styles.backgroundColor || '#f2f2f2');
    pdf.rect(x, y - fontHeight, columnWidth, fontHeight, 'F'); // Draw background
    pdf.text(header.text, x + 2, y - 2, { align: header.styles.textAlign || 'left' }); // Add text
  });
  y += fontHeight;

  // Render Rows with Styles
  rows.forEach((row) => {
    row.forEach((cell, index) => {
      const x = margin + index * columnWidth;

      // Apply cell styles
      pdf.setFontSize(parseInt(cell.styles.fontSize) || 10);
      pdf.setFont(cell.styles.fontWeight === 'bold' ? 'helvetica' : 'normal', 'normal');
      pdf.setTextColor(cell.styles.color || '#000000');
      pdf.setFillColor(cell.styles.backgroundColor || '#ffffff');
      pdf.rect(x, y - fontHeight, columnWidth, fontHeight, 'F'); // Draw background
      pdf.text(cell.text, x + 2, y - 2, { align: cell.styles.textAlign || 'left' }); // Add text
    });
    y += fontHeight;

    // Add a new page if necessary
    if (y + fontHeight > pdf.internal.pageSize.getHeight() - margin) {
      pdf.addPage();
      y = margin;
    }
  });

  // Save PDF
  pdf.save('table.pdf');
}
