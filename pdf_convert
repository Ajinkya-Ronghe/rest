convertToPDF(data: any[]): Blob {
  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 10;
  const cellPadding = 2;
  const lineHeight = 6; // Height of each line of text
  const headerHeight = 10; // Fixed height for headers

  // Extract column headers and calculate column widths
  const headers = Object.keys(data[0]);
  const columnWidths = headers.map(header => {
    const maxContentWidth = Math.max(
      pdf.getTextWidth(header),
      ...data.map(row => pdf.getTextWidth(String(row[header])))
    );
    return maxContentWidth + cellPadding * 2; // Add padding to width
  });

  // Calculate total table width and adjust for page width if needed
  const totalWidth = columnWidths.reduce((sum, width) => sum + width, 0);
  const scaleFactor = totalWidth > pageWidth - 2 * margin ? (pageWidth - 2 * margin) / totalWidth : 1;
  const adjustedWidths = columnWidths.map(width => width * scaleFactor);

  // Add title
  pdf.text('Exported Data', margin, margin);

  // Draw header row
  let currentY = margin + 10; // Start below the title
  let currentX = margin;

  headers.forEach((header, index) => {
    const width = adjustedWidths[index];
    pdf.rect(currentX, currentY, width, headerHeight); // Draw cell
    pdf.text(header, currentX + cellPadding, currentY + headerHeight / 2 + 2); // Add header text
    currentX += width; // Move to the next column
  });

  // Draw rows
  currentY += headerHeight; // Move to the next row
  data.forEach(row => {
    currentX = margin;
    let maxCellHeight = headerHeight; // Reset for each row

    headers.forEach((header, index) => {
      const width = adjustedWidths[index];
      const cellText = row[header] !== undefined ? String(row[header]) : '';
      const wrappedText = pdf.splitTextToSize(cellText, width - 2 * cellPadding);
      const cellHeight = wrappedText.length * lineHeight + cellPadding; // Calculate height based on wrapped text

      maxCellHeight = Math.max(maxCellHeight, cellHeight);

      // Draw cell
      pdf.rect(currentX, currentY, width, cellHeight);
      pdf.text(wrappedText, currentX + cellPadding, currentY + cellPadding + 4);
      currentX += width; // Move to the next column
    });

    // Move to the next row based on the tallest cell
    currentY += maxCellHeight;
  });

  // Return the PDF as a Blob
  return pdf.output('blob');
}
