private Map<String, Object> mapJsonToDto(Map<String, Object> jsonObject, Map<String, Object> schema) {
    List<Map<String, Object>> columns = (List<Map<String, Object>>) schema.get("columns");
    Map<String, Object> dto = new HashMap<>();

    // Process the main array "Patch Installation State - All Status"
    List<Map<String, Object>> patchInstallationStatusArray = (List<Map<String, Object>>) jsonObject.get("Patch Installation State - All Status");
    if (patchInstallationStatusArray != null && !patchInstallationStatusArray.isEmpty()) {
        Map<String, Object> patchStatus = patchInstallationStatusArray.get(0); // Assuming we process the first object

        for (Map<String, Object> column : columns) {
            String columnName = (String) column.get("field_name");
            String dataType = (String) column.get("data_type");

            // Check if the column is of type "Nested_JSON" (e.g., "Patch Installation State")
            if ("Nested_JSON".equals(dataType) && "Patch Installation State".equals(columnName)) {
                List<Map<String, Object>> patchInstallationStateArray = (List<Map<String, Object>>) patchStatus.get("Patch Installation State");
                if (patchInstallationStateArray != null && !patchInstallationStateArray.isEmpty()) {
                    Map<String, Object> nestedPatchState = patchInstallationStateArray.get(0); // Process first object in "Patch Installation State" array
                    List<Map<String, Object>> arrayJson = (List<Map<String, Object>>) column.get("array_json");

                    // Traverse each field inside "Patch Installation State"
                    for (Map<String, Object> nestedColumn : arrayJson) {
                        String nestedFieldName = (String) nestedColumn.get("field_name");
                        if (nestedPatchState.containsKey(nestedFieldName)) {
                            dto.put(nestedFieldName, nestedPatchState.get(nestedFieldName));
                        }
                    }
                }
                continue; // Skip adding "Patch Installation State" itself to dto
            }

            // Process top-level fields
            if (patchStatus.containsKey(columnName)) {
                dto.put(columnName, patchStatus.get(columnName));
            }
        }
    }

    // Add staging_id
    if (jsonObject.containsKey("staging_id")) {
        dto.put("staging_id", Integer.parseInt(jsonObject.get("staging_id").toString()));
    }

    // Find and add bank_id based on custom tags
    try {
        logger.debug("Trying to find bank id");
        if (jsonObject.containsKey("Custom Tag")) {
            Integer bankId = fiservIocalAccountPasswordDaoImpl.findBankByBankName(jsonObject.get("Custom Tag").toString());
            dto.put("bank_id", bankId);
        }
    } catch (Exception e) {
        logger.debug("Bank id does not exist");
    }

    try {
        logger.debug("Trying to find bank id");
        if (jsonObject.containsKey("ci_custom_tag_custom_tag")) {
            Integer bankId = fiservIocalAccountPasswordDaoImpl.findBankByBankName(jsonObject.get("ci_custom_tag_custom_tag").toString());
            dto.put("bank_id", bankId);
        }
    } catch (Exception e) {
        logger.debug("Bank id does not exist");
    }

    return dto;
}
